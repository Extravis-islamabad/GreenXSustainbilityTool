{"version":3,"file":"index.umd.min.js","sources":["../src/dom/MutationRecord.ts","../src/dom/MutationObserver.ts"],"sourcesContent":["var MutationRecord = /** @class */ (function () {\n    function MutationRecord(type, target) {\n        this.type = type;\n        this.target = target;\n        this.addedNodes = [];\n        this.attributeName = null;\n        this.attributeNamespace = null;\n        this.nextSibling = null;\n        this.oldValue = null;\n        this.previousSibling = null;\n        this.removedNodes = [];\n    }\n    MutationRecord.copy = function (original) {\n        var record = new MutationRecord(original.type, original.target);\n        record.addedNodes = original.addedNodes.slice();\n        record.removedNodes = original.removedNodes.slice();\n        record.previousSibling = original.previousSibling;\n        record.nextSibling = original.nextSibling;\n        record.attributeName = original.attributeName;\n        record.attributeNamespace = original.attributeNamespace;\n        record.oldValue = original.oldValue;\n        return record;\n    };\n    return MutationRecord;\n}());\nexport { MutationRecord };\n//# sourceMappingURL=MutationRecord.js.map","import { ElementEvent, MutationEvent, runtime } from '@antv/g-lite';\nimport { MutationRecord } from './MutationRecord';\nvar uidCounter = 0;\nvar registrationsTable = new WeakMap();\nvar Registration = /** @class */ (function () {\n    function Registration(observer, target, options) {\n        this.observer = observer;\n        this.target = target;\n        this.options = options;\n        this.transientObservedNodes = [];\n    }\n    Registration.prototype.enqueue = function (record) {\n        var records = this.observer.records;\n        var length = records.length;\n        // There are cases where we replace the last record with the new record.\n        // For example if the record represents the same mutation we need to use\n        // the one with the oldValue. If we get same record (this can happen as we\n        // walk up the tree) we ignore the new record.\n        if (records.length > 0) {\n            var lastRecord = records[length - 1];\n            var recordToReplaceLast = selectRecord(lastRecord, record);\n            if (recordToReplaceLast) {\n                records[length - 1] = recordToReplaceLast;\n                return;\n            }\n        }\n        else {\n            scheduleCallback(this.observer);\n        }\n        records[length] = record;\n    };\n    Registration.prototype.addListeners = function () {\n        this.addListeners_(this.target);\n    };\n    Registration.prototype.addListeners_ = function (node) {\n        var options = this.options;\n        if (options.attributes)\n            node.addEventListener(ElementEvent.ATTR_MODIFIED, this, true);\n        // if (options.characterData) node.addEventListener('DOMCharacterDataModified', this, true);\n        if (options.childList)\n            node.addEventListener(ElementEvent.INSERTED, this, true);\n        if (options.childList || options.subtree)\n            node.addEventListener(ElementEvent.REMOVED, this, true);\n    };\n    Registration.prototype.removeListeners = function () {\n        this.removeListeners_(this.target);\n    };\n    Registration.prototype.removeListeners_ = function (node) {\n        var options = this.options;\n        if (options.attributes)\n            node.removeEventListener(ElementEvent.ATTR_MODIFIED, this, true);\n        // if (options.characterData) node.removeEventListener('DOMCharacterDataModified', this, true);\n        if (options.childList)\n            node.removeEventListener(ElementEvent.INSERTED, this, true);\n        if (options.childList || options.subtree)\n            node.removeEventListener(ElementEvent.REMOVED, this, true);\n    };\n    /**\n     * Adds a transient observer on node. The transient observer gets removed\n     * next time we deliver the change records.\n     */\n    // addTransientObserver(node: IElement) {\n    //   // Don't add transient observers on the target itself. We already have all\n    //   // the required listeners set up on the target.\n    //   if (node === this.target) return;\n    //   this.addListeners_(node);\n    //   this.transientObservedNodes.push(node);\n    //   let registrations = registrationsTable.get(node);\n    //   if (!registrations) registrationsTable.set(node, (registrations = []));\n    //   // We know that registrations does not contain this because we already\n    //   // checked if node === this.target.\n    //   registrations.push(this);\n    // }\n    Registration.prototype.removeTransientObservers = function () {\n        var transientObservedNodes = this.transientObservedNodes;\n        this.transientObservedNodes = [];\n        transientObservedNodes.forEach(function (node) {\n            // Transient observers are never added to the target.\n            this.removeListeners_(node);\n            var registrations = registrationsTable.get(node);\n            for (var i = 0; i < registrations.length; i++) {\n                if (registrations[i] === this) {\n                    registrations.splice(i, 1);\n                    // Each node can only have one registered observer associated with\n                    // this observer.\n                    break;\n                }\n            }\n        }, this);\n    };\n    Registration.prototype.handleEvent = function (e) {\n        // Stop propagation since we are managing the propagation manually.\n        // This means that other mutation events on the page will not work\n        // correctly but that is by design.\n        e.stopImmediatePropagation();\n        var record;\n        var target;\n        switch (e.type) {\n            case ElementEvent.ATTR_MODIFIED:\n                // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n                var name_1 = e.attrName;\n                // @ts-ignore\n                var namespace_1 = e.relatedNode.namespaceURI;\n                target = e.target;\n                // 1.\n                record = getRecord('attributes', target);\n                record.attributeName = name_1;\n                record.attributeNamespace = namespace_1;\n                // 2.\n                var oldValue_1 = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n                forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n                    // 3.1, 4.2\n                    if (!options.attributes)\n                        return;\n                    // 3.2, 4.3\n                    if (options.attributeFilter &&\n                        options.attributeFilter.length &&\n                        options.attributeFilter.indexOf(name_1) === -1 &&\n                        options.attributeFilter.indexOf(namespace_1) === -1) {\n                        return;\n                    }\n                    // 3.3, 4.4\n                    if (options.attributeOldValue)\n                        return getRecordWithOldValue(oldValue_1);\n                    // 3.4, 4.5\n                    return record;\n                });\n                break;\n            // case 'DOMCharacterDataModified':\n            //   // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n            //   var target = e.target;\n            //   // 1.\n            //   var record = getRecord('characterData', target);\n            //   // 2.\n            //   var oldValue = e.prevValue;\n            //   forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n            //     // 3.1, 4.2\n            //     if (!options.characterData)\n            //       return;\n            //     // 3.2, 4.3\n            //     if (options.characterDataOldValue)\n            //       return getRecordWithOldValue(oldValue);\n            //     // 3.3, 4.4\n            //     return record;\n            //   });\n            //   break;\n            case ElementEvent.REMOVED:\n            // this.addTransientObserver(e.target as IElement);\n            // Fall through.\n            case ElementEvent.INSERTED:\n                // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n                target = e.relatedNode;\n                var changedNode = e.target;\n                var addedNodes = void 0;\n                var removedNodes = void 0;\n                if (e.type === ElementEvent.INSERTED) {\n                    addedNodes = [changedNode];\n                    removedNodes = [];\n                }\n                else {\n                    addedNodes = [];\n                    removedNodes = [changedNode];\n                }\n                var previousSibling = changedNode.previousSibling;\n                var nextSibling = changedNode.nextSibling;\n                // 1.\n                record = getRecord('childList', target);\n                record.addedNodes = addedNodes;\n                record.removedNodes = removedNodes;\n                record.previousSibling = previousSibling;\n                record.nextSibling = nextSibling;\n                forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n                    // 2.1, 3.2\n                    if (!options.childList)\n                        return;\n                    // 2.2, 3.3\n                    return record;\n                });\n        }\n        clearRecords();\n    };\n    return Registration;\n}());\nexport { Registration };\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\n * @see https://github.com/googlearchive/MutationObservers/blob/master/MutationObserver.js\n */\nvar MutationObserver = /** @class */ (function () {\n    function MutationObserver(callback) {\n        this.callback = callback;\n        this.nodes = [];\n        this.records = [];\n        this.uid = uidCounter++;\n    }\n    MutationObserver.prototype.observe = function (target, options) {\n        // 1.1\n        if ((!options.childList && !options.attributes && !options.characterData) ||\n            // 1.2\n            (options.attributeOldValue && !options.attributes) ||\n            // 1.3\n            (options.attributeFilter &&\n                options.attributeFilter.length &&\n                !options.attributes) ||\n            // 1.4\n            (options.characterDataOldValue && !options.characterData)) {\n            throw new SyntaxError();\n        }\n        var registrations = registrationsTable.get(target);\n        if (!registrations)\n            registrationsTable.set(target, (registrations = []));\n        // 2\n        // If target's list of registered observers already includes a registered\n        // observer associated with the context object, replace that registered\n        // observer's options with options.\n        var registration;\n        for (var i = 0; i < registrations.length; i++) {\n            if (registrations[i].observer === this) {\n                registration = registrations[i];\n                registration.removeListeners();\n                registration.options = options;\n                break;\n            }\n        }\n        // 3.\n        // Otherwise, add a new registered observer to target's list of registered\n        // observers with the context object as the observer and options as the\n        // options, and add target to context object's list of nodes on which it\n        // is registered.\n        if (!registration) {\n            registration = new Registration(this, target, options);\n            registrations.push(registration);\n            this.nodes.push(target);\n        }\n        registration.addListeners();\n    };\n    MutationObserver.prototype.disconnect = function () {\n        var _this = this;\n        this.nodes.forEach(function (node) {\n            var registrations = registrationsTable.get(node);\n            for (var i = 0; i < registrations.length; i++) {\n                var registration = registrations[i];\n                if (registration.observer === _this) {\n                    registration.removeListeners();\n                    registrations.splice(i, 1);\n                    // Each node can only have one registered observer associated with\n                    // this observer.\n                    break;\n                }\n            }\n        }, this);\n        this.records = [];\n    };\n    MutationObserver.prototype.takeRecords = function () {\n        var copyOfRecords = this.records;\n        this.records = [];\n        return copyOfRecords;\n    };\n    return MutationObserver;\n}());\nexport { MutationObserver };\n// We keep track of the two (possibly one) records used in a single mutation.\nvar currentRecord;\nvar recordWithOldValue;\n/**\n * Creates a record without |oldValue| and caches it as |currentRecord| for\n * later use.\n */\nfunction getRecord(type, target) {\n    return (currentRecord = new MutationRecord(type, target));\n}\n/**\n * Gets or creates a record with |oldValue| based in the |currentRecord|\n */\nfunction getRecordWithOldValue(oldValue) {\n    if (recordWithOldValue)\n        return recordWithOldValue;\n    recordWithOldValue = MutationRecord.copy(currentRecord);\n    recordWithOldValue.oldValue = oldValue;\n    return recordWithOldValue;\n}\nfunction clearRecords() {\n    currentRecord = recordWithOldValue = undefined;\n}\n/**\n * Whether the record represents a record from the current\n * mutation event.\n */\nfunction recordRepresentsCurrentMutation(record) {\n    return record === recordWithOldValue || record === currentRecord;\n}\n/**\n * Selects which record, if any, to replace the last record in the queue.\n * This returns |null| if no record should be replaced.\n */\nfunction selectRecord(lastRecord, newRecord) {\n    if (lastRecord === newRecord)\n        return lastRecord;\n    // Check if the the record we are adding represents the same record. If\n    // so, we keep the one with the oldValue in it.\n    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))\n        return recordWithOldValue;\n    return null;\n}\nfunction removeTransientObserversFor(observer) {\n    observer.nodes.forEach(function (node) {\n        var registrations = registrationsTable.get(node);\n        if (!registrations)\n            return;\n        registrations.forEach(function (registration) {\n            if (registration.observer === observer)\n                registration.removeTransientObservers();\n        });\n    });\n}\n/**\n * This function is used for the \"For each registered observer observer (with\n * observer's options as options) in target's list of registered observers,\n * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n * each registered observer observer (with options options) in ancestor's list\n * of registered observers, run these substeps:\" part of the algorithms. The\n * |options.subtree| is checked to ensure that the callback is called\n * correctly.\n *\n * @param {Node} target\n * @param {function(MutationObserverInit):MutationRecord} callback\n */\nfunction forEachAncestorAndObserverEnqueueRecord(target, callback) {\n    for (var node = target; node; node = node.parentNode) {\n        var registrations = registrationsTable.get(node);\n        if (registrations) {\n            for (var j = 0; j < registrations.length; j++) {\n                var registration = registrations[j];\n                var options = registration.options;\n                // Only target ignores subtree.\n                if (node !== target && !options.subtree)\n                    continue;\n                var record = callback(options);\n                if (record)\n                    registration.enqueue(record);\n            }\n        }\n    }\n}\n// This is used to ensure that we never schedule 2 callas to setImmediate\nvar isScheduled = false;\n// Keep track of observers that needs to be notified next time.\nvar scheduledObservers = [];\n/**\n * Schedules |dispatchCallback| to be called in the future.\n */\nfunction scheduleCallback(observer) {\n    scheduledObservers.push(observer);\n    if (!isScheduled) {\n        isScheduled = true;\n        // setImmediate(dispatchCallbacks);\n        if (typeof runtime.globalThis !== 'undefined') {\n            runtime.globalThis.setTimeout(dispatchCallbacks);\n        }\n        else {\n            dispatchCallbacks();\n        }\n    }\n}\nfunction dispatchCallbacks() {\n    // http://dom.spec.whatwg.org/#mutation-observers\n    isScheduled = false; // Used to allow a new setImmediate call above.\n    var observers = scheduledObservers;\n    scheduledObservers = [];\n    // Sort observers based on their creation UID (incremental).\n    observers.sort(function (o1, o2) {\n        return o1.uid - o2.uid;\n    });\n    var anyNonEmpty = false;\n    observers.forEach(function (observer) {\n        // 2.1, 2.2\n        var queue = observer.takeRecords();\n        // 2.3. Remove all transient registered observers whose observer is mo.\n        removeTransientObserversFor(observer);\n        // 2.4\n        if (queue.length) {\n            // @ts-ignore\n            observer.callback(queue, observer);\n            anyNonEmpty = true;\n        }\n    });\n    // 3.\n    if (anyNonEmpty)\n        dispatchCallbacks();\n}\n//# sourceMappingURL=MutationObserver.js.map"],"names":["currentRecord","recordWithOldValue","MutationRecord","type","target","this","addedNodes","attributeName","attributeNamespace","nextSibling","oldValue","previousSibling","removedNodes","copy","original","record","slice","uidCounter","registrationsTable","WeakMap","Registration","observer","options","transientObservedNodes","prototype","enqueue","records","length","recordToReplaceLast","lastRecord","newRecord","recordRepresentsCurrentMutation","selectRecord","scheduledObservers","push","isScheduled","runtime","globalThis","setTimeout","dispatchCallbacks","addListeners","addListeners_","node","attributes","addEventListener","ElementEvent","ATTR_MODIFIED","childList","INSERTED","subtree","REMOVED","removeListeners","removeListeners_","removeEventListener","removeTransientObservers","forEach","registrations","get","i","splice","handleEvent","e","stopImmediatePropagation","name_1","attrName","namespace_1","relatedNode","namespaceURI","getRecord","oldValue_1","attrChange","MutationEvent","ADDITION","prevValue","forEachAncestorAndObserverEnqueueRecord","attributeFilter","indexOf","attributeOldValue","changedNode","undefined","MutationObserver","callback","nodes","uid","observe","characterData","characterDataOldValue","SyntaxError","registration","set","disconnect","_this","takeRecords","copyOfRecords","parentNode","j","observers","sort","o1","o2","anyNonEmpty","queue","removeTransientObserversFor"],"mappings":"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"}