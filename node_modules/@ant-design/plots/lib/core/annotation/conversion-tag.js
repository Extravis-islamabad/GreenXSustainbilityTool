"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversionTag = void 0;
// @ts-expect-error
var g_1 = require("@antv/g");
var utils_1 = require("../utils");
var ConversionTag = /** @class */ (function () {
    function ConversionTag(chart, options) {
        this.container = [];
        if (!options)
            return;
        this.chart = chart;
        this.options = options;
        this.init();
    }
    ConversionTag.prototype.getElementsLayout = function () {
        var elements = this.canvas.document.getElementsByClassName('element');
        var elementsLayout = [];
        elements.forEach(function (element) {
            var bbox = element.getBBox();
            var x = bbox.x, y = bbox.y, width = bbox.width, height = bbox.height;
            elementsLayout.push({
                bbox: bbox,
                x: x,
                y: y,
                width: width,
                height: height,
                data: element['__data__'],
            });
        });
        return elementsLayout;
    };
    ConversionTag.prototype.getConversionTagLayout = function () {
        var isVertical = this.direction === 'vertical';
        var elementsLayout = this.getElementsLayout();
        var _a = elementsLayout[0], firstX = _a.x, firstY = _a.y, firstHeigt = _a.height, firstWidth = _a.width, firstData = _a.data;
        var valuePath = ['items', 0, 'value'];
        var preValue = (0, utils_1.get)(firstData, valuePath);
        var elementDistance = isVertical
            ? elementsLayout[1].y - firstY - firstHeigt
            : elementsLayout[1].x - firstX - firstWidth;
        var tagLayout = [];
        var _b = this.options, _c = _b.size, size = _c === void 0 ? 40 : _c, _d = _b.arrowSize, arrowSize = _d === void 0 ? 20 : _d, _e = _b.spacing, spacing = _e === void 0 ? 4 : _e;
        elementsLayout.forEach(function (element, index) {
            if (index > 0) {
                var x = element.x, y = element.y, height = element.height, width = element.width, data = element.data;
                var currentValue = (0, utils_1.get)(data, valuePath);
                var halfSize = size / 2;
                if (isVertical) {
                    var arrowVertexX = x + width / 2;
                    var arrowVertexY = y;
                    tagLayout.push({
                        points: [
                            [arrowVertexX + halfSize, arrowVertexY - elementDistance + spacing],
                            [arrowVertexX + halfSize, arrowVertexY - arrowSize - spacing],
                            [arrowVertexX, arrowVertexY - spacing],
                            [arrowVertexX - halfSize, arrowVertexY - arrowSize - spacing],
                            [arrowVertexX - halfSize, arrowVertexY - elementDistance + spacing],
                        ],
                        center: [arrowVertexX, arrowVertexY - elementDistance / 2 - spacing],
                        width: elementDistance,
                        value: [preValue, currentValue],
                    });
                }
                else {
                    var arrowVertexX = x;
                    var arrowVertexY = y + height / 2;
                    tagLayout.push({
                        points: [
                            [x - elementDistance + spacing, arrowVertexY - halfSize],
                            [x - arrowSize - spacing, arrowVertexY - halfSize],
                            [arrowVertexX - spacing, arrowVertexY],
                            [x - arrowSize - spacing, arrowVertexY + halfSize],
                            [x - elementDistance + spacing, arrowVertexY + halfSize],
                        ],
                        center: [arrowVertexX - elementDistance / 2 - spacing, arrowVertexY],
                        width: elementDistance,
                        value: [preValue, currentValue],
                    });
                }
                preValue = currentValue;
            }
        });
        return tagLayout;
    };
    ConversionTag.prototype.init = function () {
        var canvas = this.chart.getContext().canvas;
        this.canvas = canvas;
        this.setDirection();
        this.drawConversionTag();
    };
    /** 根据 coordinate 确定方向 */
    ConversionTag.prototype.setDirection = function () {
        var coordinate = this.chart.getCoordinate();
        var transformations = (0, utils_1.get)(coordinate, 'options.transformations');
        var direction = 'horizontal';
        transformations.forEach(function (transformation) {
            if (transformation.includes('transpose')) {
                direction = 'vertical';
            }
        });
        this.direction = direction;
    };
    ConversionTag.prototype.drawConversionTag = function () {
        var _this = this;
        var conversionLayout = this.getConversionTagLayout();
        var _a = this.options, style = _a.style, _b = _a.text, textStyle = _b.style, formatter = _b.formatter;
        conversionLayout.forEach(function (layout) {
            var points = layout.points, center = layout.center, value = layout.value;
            var prev = value[0], next = value[1];
            var x = center[0], y = center[1];
            var polygon = new g_1.Polygon({
                style: __assign({ points: points, fill: '#eee' }, style),
            });
            var text = new g_1.Text({
                style: __assign({ x: x, y: y, text: (0, utils_1.isFunction)(formatter) ? formatter(prev, next) : ((next / prev) * 100).toFixed(2) + '%', fontSize: 12, textBaseline: 'middle', textAlign: 'center', fill: '#000' }, textStyle),
            });
            _this.canvas.appendChild(polygon);
            _this.canvas.appendChild(text);
            _this.container.push(polygon, text);
        });
    };
    ConversionTag.prototype.update = function (options) { };
    ConversionTag.prototype.destroy = function () {
        this.container.forEach(function (child) {
            child.destroy();
        });
    };
    return ConversionTag;
}());
exports.ConversionTag = ConversionTag;
